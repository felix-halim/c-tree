<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<style type="text/css">
.axis path,
.axis line {
  fill: none;
  stroke: black;
}
.line {
  fill: none;
  stroke: steelblue;
  stroke-width: 1.5px;
}
</style>
<script src="d3.v3.min.js"></script>
<script src="data.js"></script>
<script src="linechart.js"></script>
<script>
data = d3.csv.parse(data);

data.forEach(function (d) {
  d.Q = parseInt(d.Q);
  d.insert_time = parseFloat(d.insert_time);
  d.query_time = parseFloat(d.query_time) + 1e-9;
  d.update_time = parseFloat(d.update_time) + 1e-9;
  d.total_time = d.insert_time + d.query_time + d.update_time;
});

var algo_name = {
  comb:            { name: "COMB", symbol: "diamond", color: "orange" },
  art:             { name: "ART", symbol: "diamond", color: "red", },
  art_best:        { name: "ARTC", symbol: "cross", color: "red", },
  art_best_eager:  { name: "ART", symbol: "triangle-up", color: "green", },
  sort:            { name: "Sort", symbol: "triangle-down", color: "blue", },
  crack:           { name: "Crack", symbol: "circle", color: "red", },
  ctree_32_64:     { name: "CT64", symbol: "square", color: "blue", },
  ctree_32_1024:   { name: "CT1024", symbol: "circle", color: "magenta", },
  ctree_32_4096:   { name: "BT4096", symbol: "diamond", color: "blue", },
  ctree_eager:     { name: "BTE", symbol: "triangle-up", color: "magenta", },
};

function filter(filters) {
  var ret = data;
  filters.forEach(function (filter) {
    ret = ret.filter(function (d) {
      return filter.values.indexOf(d[filter.attr]) != -1;
    });
  });
  return ret;
}

function group(arr, by) {
  var keys = {}, groups = [];
  arr.forEach(function (d) {
    if (!keys[d[by]]) keys[d[by]] = [];
    keys[d[by]].push(d);
  });
  return keys;
  // for (var i in keys) if (keys.hasOwnProperty(i)) {
  //   var a = keys[i];
  //   keys[i] = [];
  //   groups.push({ group: i, label: a.label, x: a.x, y: a.y });
  // }
}

function expTime(t) {
  function f(x) {
    var v = d3.format(".2f")(x) + "";
    while (v.length > 0 && v[v.length - 1] == '0') v = v.substring(0, v.length - 1);
    if (v.length > 0 && v[v.length - 1] == '.') v = v.substring(0, v.length - 1);
    console.log(v);
    return v;
  }
  if (t >= 3600) return f(t / 3600) + 'h';
  if (t >= 60) return f(t / 60) + 'm';
  if (t >= 1) return f(t) + 's';
  if (t >= 1e-3) return f(t*1e3) + 'ms';
  if (t >= 1e-6) return f(t*1e6) + 'Âµs';
  return "?";
};

function renderCharts() {
  var charts = document.getElementsByClassName('chart');
  Array.prototype.forEach.call(charts, linechart);
}
</script>
</head>

<body onload="renderCharts()">
<h1>New experiments on CTree and ART</h1>

<p>All experiments uses N = 10^8 random sparse 32 bit integer.<br>
The queries are random point queries.<br>
The updates are random point updates in the same 32 bit integer domain.<br>
</p>

<h2>Read Only</h2>

<div class="chart">{
  xAxis: { label: 'Query Sequence',  attr: 'Q', scale: 'log', domain: [0.5, 2e9], format: ticksPow10, ticks: [1, 10, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9], margin: 40 },
  yAxis: { label: 'NOUP: Ratio to Sort', attr: 'total_time', scale: 'logx', domain: [0, 4], format: noFormat, ticks: [0, 1, 2, 3, 4], margin: 40 },
  legend: {
    'sort' : { x: 100, y: 20 },
    'art_best_eager' : { x: 100, y: 40 },
    'crack' : { x: 100, y: 60 },
    'comb' : { x: 100, y: 80 },
  },
  base: 'sort',
  data: group(filter([
    { attr: 'update_workload',   values: ['NOUP'] },
    { attr: 'algorithm',         values: ['sort', 'art_best_eager', 'comb', 'crack'] },
  ]), 'algorithm'),
}</div>

<p>Cumulative runtime compared to Sort under read only queries.
<ul>
<li>COMB is consistently faster than Crack on 10th+ queries.
<li>COMB is <b>never worse</b> than std::Sort on any number of queries.
<li>ART is faster than std::sort in initialization costs.
<li>ART is perforamnce is consistently fast O(K) per query.
<li>ART wins for large number of queries.
<li>Note for ART: if K is large, it may be a different story.
</ul>
</p>


<h2>Low Frequency High Volume (LFHV) Updates</h2>

<div class="chart">{
  xAxis: { label: 'Query Sequence',  attr: 'Q', scale: 'log', domain: [0.5, 2e9], format: ticksPow10, ticks: [1, 10, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8 ], margin: 40 },
  yAxis: { label: 'LFHV: Ratio to CTree', attr: 'total_time', scale: 'logx', domain: [0, 3], format: d3.format('s'), ticks: [0, 1, 2, 3, 4, 5, 6, 7], margin: 40 },
  base: 'comb',
  legend: {
    'ctree_32_64' : { x: 100, y: 45 },
    'ctree_32_1024' : { x: 170, y: 15 },
    'crack' : { x: 255, y: 35 },
    'comb' : { x: 100, y: 120 },
  },
  data: group(filter([
    { attr: 'update_workload',   values: ['LFHV'] },
    { attr: 'algorithm',         values: ['crack', 'comb', 'ctree_32_64', 'ctree_32_1024'] },
  ]), 'algorithm'),
}</div>


<p>Cumulative runtime compared to COMB under LFHV updates.
<ul>
<li>COMB is consistently faster than Crack on 10th+ queries.
<li>CTree with 64 bucket size (CT64) is worse than COMB due inefficient Fusion.
<li>CTree with 1024 bucket size (CT1024) has better Fusion but worse for updating large Bucket without index.
<li>CTree can be modified to be "adaptive" in terms of bucket size (need more research).
</ul>
</p>

<h2>Fusion Effectiveness on Different Bucket Sizes</h2>

<p>Cumulative runtime compared to COMB under LFHV updates.
<ul>
<li>COMB is consistently faster than Crack on 10th+ queries.
<li>CTree with 64 bucket size (CT64) is worse than COMB due inefficient Fusion.
<li>CTree with 1024 bucket size (CT1024) has better Fusion but worse for updating large Bucket without index.
<li>CTree can be modified to be "adaptive" in terms of bucket size (need more research).
</ul>
</p>

<div class="chart">{
  xAxis: { label: 'Query Sequence',  attr: 'Q', scale: 'log', domain: [0.5, 1e9], format: ticksPow10, ticks: [1, 10, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9], margin: 40 },
  yAxis: { label: 'Cumulative Runtime', attr: 'total_time', scale: 'log', domain: [0.015, 1000], format: ticksPow10, ticks: [0.15, 1, 10, 100, 1000], margin: 40 },
  data: group(filter([
    { attr: 'update_workload',   values: ['APPEND'] },
    { attr: 'algorithm',         values: [
      'comb',
      'ctree_32_64',
      'crack',
    ] },
  ]), 'algorithm'),
}</div>


<div class="chart">{
  xAxis: { label: 'Query Sequence',  attr: 'Q', scale: 'log', domain: [0.5, 1e9], format: null, ticks: [1, 10, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9], margin: 40 },
  yAxis: { label: 'Cumulative Runtime', attr: 'total_time', scale: 'log', domain: [0.3, 10000], format: null, ticks: [1, 10, 100, 1000, 1e4], margin: 40 },
  legend: {
    'sort' : { x: 100, y: 10 },
    'crack' : { x: 100, y: 30 },
  },
  data: group(filter([
    { attr: 'update_workload',   values: ['NOUP'] },
    { attr: 'algorithm',         values: [
      'sort',
      'crack',
    ] },
  ]), 'algorithm'),
}</div>


<div class="chart">{
  xAxis: { label: 'Query Sequence',  attr: 'Q', scale: 'log', domain: [0.5, 2e9], format: ticksPow10, ticks: [1, 10, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9], margin: 40 },
  yAxis: { label: 'Ratio to Sort', attr: 'total_time', scale: 'logx', domain: [0, 4], format: noFormat, ticks: [0, 1, 2, 3, 4], margin: 40 },
  base: 'sort',
  legend: {
    'sort' : { x: 100, y: 10 },
    'crack' : { x: 100, y: 30 },
    'comb' : { x: 100, y: 50 },
    'ctree_32_4096' : { x: 100, y: 70 },
  },
  data: group(filter([
    { attr: 'update_workload',   values: ['NOUP'] },
    { attr: 'algorithm',         values: [
      'sort',
      'crack',
      'comb',
      'ctree_32_1024',
      'ctree_32_4096',
    ] },
  ]), 'algorithm'),
}</div>


<div class="chart">{
  xAxis: { label: 'Query Sequence',  attr: 'Q', scale: 'log', domain: [0.5, 1e9], format: ticksPow10, ticks: [1, 10, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9], margin: 40 },
  yAxis: { label: 'Cumulative Runtime', attr: 'total_time', scale: 'logx', domain: [0.1, 7], format: d3.format('s'), ticks: [0, 1, 2, 3, 4, 5, 6, 7], margin: 40 },
  base: 'ctree_32_64',
  legend: {
    'ctree_32_64' : { x: 100, y: 10 },
    'crack' : { x: 100, y: 30 },
    'comb' : { x: 100, y: 50 },
  },
  data: group(filter([
    { attr: 'update_workload',   values: ['QUEUE'] },
    { attr: 'algorithm',         values: [
      'crack',
      'comb',
      'ctree_32_64',
    ] },
  ]), 'algorithm'),
}</div>


<div class="chart">{
  xAxis: { label: 'Query Sequence',  attr: 'Q', scale: 'log', domain: [0.5, 1e9], format: ticksPow10, ticks: [1, 10, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9], margin: 40 },
  yAxis: { label: 'Cumulative Runtime', attr: 'total_time', scale: 'logx', domain: [0.1, 7], format: d3.format('s'), ticks: [0, 1, 2, 3, 4, 5, 6, 7], margin: 40 },
  base: 'ctree_32_64',
  legend: {
    'ctree_32_64' : { x: 100, y: 10 },
    'crack' : { x: 100, y: 30 },
    'comb' : { x: 100, y: 50 },
    'ctree_32_4096' : { x: 100, y: 70 },
    'ctree_32_1024' : { x: 100, y: 70 },
  },
  data: group(filter([
    { attr: 'update_workload',   values: ['TRASH'] },
    { attr: 'algorithm',         values: [
      'crack',
      'comb',
      'ctree_32_64',
      'ctree_32_1024',
      'ctree_32_4096',
    ] },
  ]), 'algorithm'),
}</div>
</body>
